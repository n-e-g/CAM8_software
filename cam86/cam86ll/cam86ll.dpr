// --------------------------------------------------------------------------------
// ASCOM Camera driver low-level interaction library for cam88 v.0.1
// Edit Log:
// Date Who Vers Description
// ----------- --- ----- ---------------------------------------------------------
// 28-aug-2016 VSS 0.1 Initial release (code obtained from grim)
// --------------------------------------------------------------------------------

library cam86ll;

uses
  Classes,
  SysUtils,
  MyD2XX,
  MMSystem,
  Windows,
  SyncObjs,
  ExtCtrls;

{$R *.res}

const
    //?????? ???????????
    CameraWidth  = 3000;
    //?????? ???????????
    CameraHeight = 2000; 
    //?????????????? ???????? ?? ??????? ????? BDBUS
    portfirst = $11;
    xccd = 1500;
    yccd = 1000;
    //bitbang speed
    spusb = 20000;

    //camera state consts
    cameraIdle = 0;
    cameraWaiting = 1;
    cameraExposing = 2;
    cameraReading = 3;
    cameraDownload = 4;
    cameraError = 5;

    TemperatureOffset = 1280;
    MinErrTemp = -120.0;
    MaxErrTemp = 120.0;
    TRUE_INV_PROT = $aa55;
    FALSE_INV_PROT = $55aa;
    HIGH_MASK_PROT = $aa00;

    //driver image type
    type camera_image_type = array [0..CameraHeight*CameraWidth-1] of integer;

    //Class for reading thread
    posl = class(TThread)
    private
    //Private declarations
    protected
    procedure Execute; override;
    end;

//GLobal variables}
var   
    //??????????-????, ?????????? ????????? ?????????? ? ???????
    isConnected : boolean = false;
    //????????? ???????? ?????? ? ???????? ?????? FT2232HL        
    adress : integer;
    //???????
    mBin : integer;
    //??????????-????, ?????????? ?????????? ? ?????????? ?????
    imageReady : boolean = false;
    //??????????-????????? ??????  0 - ready 1 - longexp 2 - read
    cameraState : integer = 0;
    //?????? ??????????
    ExposureTimer : integer;
    //?????????? ??? ??????? ?????? (?????? ???????????)
    co : posl;
    //???????? ??????-??????????? ??? ????????
    bufim : camera_image_type;
    //?????? ?????? ? ?????????? ?? ???????
    mYn, mdeltY : integer;
    kolbyte : integer;
    eexp : integer;

    siin : array[0..3] of byte;
    siout : word;

    //error Flag
    errorReadFlag : boolean;
    errorWriteFlag : boolean;

    //cached values
    sensorTempCache : Double;
    targetTempCache : Double;
    coolerOnCache : WordBool;
    coolerPowerCache : Double;


// -------------------------------------------------------------------------------
// Infrastructure part
// -------------------------------------------------------------------------------

// ????????? ????????? ?????? ? FT2232LH.
// ?????? ???????????? ????? ?????:
// 1. ??????? ??????????? ????? ? ????????? ??????? (??????????? ?????????????????? ????????? ?? ??????? ????? BDBUS).
// ??? ???? ???????????????? ????????? adress.
// 2. ????? ???? ???? ?????? ?????????? ?? ????? ????????: n:=Write_USB_Device_Buffer(FT_CAM8B,adress);
// ????????????? ?????????? FT2232HL ?????? ??? ???????? ??? ??? ???????? ?? ???? ???? BDBUS. ???????? 1 ????? ??? ???? ???????? 65 ??.
// ????? ????????? ????????? ??????? n:=Write_USB_Device_Buffer(FT_CAM8B,adress) ??????? ?? ????????????? ??????????? ? ?? ??????????????
// ????. ??????? ??????????? ?????????????????? ????????? ????? ????????? ???, ? ?? ?????????? ?? ???????.
// ????? ?????????? ????? ???????? ??? ????????? (? ???? ????????? ?? 24 ?????!) ??? ????? ????? ???????? ????? D2XX.pas, ? ?????? ??? MyD2XX.pas

function Qbuf():integer;
begin
    Get_USB_Device_QueueStatus(FT_HANDLEA);
    result:=FT_Q_Bytes;
end;

procedure sspi;
var i,j:integer;
    b:byte;
    n:word;
begin
    n:=100;
    FillChar(FT_Out_Buffer,n,portfirst);
    for j:=0 to 2 do
    begin
        b:=siin[j];
        for i:= 0 to 7 do
        begin
            inc(FT_Out_Buffer[2*i+1+16*j],$20);
            if (b and $80) = $80 then
            begin
                inc(FT_Out_Buffer[2*i+16*j],$80);
                inc(FT_Out_Buffer[2*i+1+16*j],$80);
            end;
            b:=b*2;
        end;
    end;
    if (not errorWriteFlag) then
    begin
        errorWriteFlag := Write_USB_Device_Buffer_wErr(FT_HANDLEB,@FT_Out_Buffer,n);
    end;
end;

procedure sspo;
var i:integer;
    b:word;
    n:word;
	byteCnt, byteExpected : Word;
begin
    n:=100;
	  byteCnt := 0;
    byteExpected := n;
    if (not errorWriteFlag) then
    begin
        byteCnt := Read_USB_Device_Buffer(FT_HANDLEB,n);
    end;
    if (byteCnt<>byteExpected) then
    begin
        errorReadFlag:=true;
    end;
	
    b:=0;
    for i:=0 to 15 do
    begin
        b:=b*2;
        if (FT_In_Buffer[i+1+8] and $40) <> 0 then
        begin
            inc(b);
        end;
    end;
    siout:=b;
end;

procedure Spi_comm(comm:byte;param:word);
begin
    Purge_USB_Device_In(FT_HANDLEB);
    Purge_USB_Device_Out(FT_HANDLEB);
    siin[0]:=comm;
    siin[1]:=hi(param);
    siin[2]:=lo(param);
    sspi;
    sspo;
    sleep(20);
end;

procedure ComRead;
begin
    co:=posl.Create(true);
    co.FreeOnTerminate:=true;
    co.Priority:=tpNormal;
    co.Resume;
end;

procedure posl.Execute;
// ?????????? ???? ?????? ??????? ????? ???? ADBUS
// ?????? ?????????????? ?????????? ?????? FT2232HL ? ???????? ?????? ???????????
// ??-?? ???????????? AD9822 ????????? ??????? ??????? ????, ????? ???????, ? ? delphi ????????.
// ?????????? ?????  ??? integer32, ? ?? word16 ??-?? ???????????? ??? ??????????? ????????? 
var x, y:integer;
    byteCnt : Word;
    byteExpected : Word;
begin
    byteCnt := 0;
    byteExpected := kolbyte;
    if (not errorWriteFlag) then
    begin
        byteCnt := Read_USB_Device_Buffer(FT_HANDLEA,kolbyte);
    end;
    if (byteCnt<>byteExpected) then
    begin
        errorReadFlag:=true;
        if (not errorWriteFlag) then
        begin
            Purge_USB_Device_IN(FT_HANDLEA);
            Purge_USB_Device_OUT(FT_HANDLEA);
        end;
    end
    else begin
        if mBin = 0 then
        begin
            for y:= 0 to mdeltY-1 do
            begin
                for x:=0 to 1499 do
                begin
                    bufim[2*x+0+(2*(y+mYn)+0)*3000]:=swap(FT_In_Buffer[4*x+4+y*6004]);
                    bufim[2*x+0+(2*(y+mYn)+1)*3000]:=swap(FT_In_Buffer[4*x+5+y*6004]);
                    bufim[2*x+1+(2*(y+mYn)+1)*3000]:=swap(FT_In_Buffer[4*x+6+y*6004]);
                    bufim[2*x+1+(2*(y+mYn)+0)*3000]:=swap(FT_In_Buffer[4*x+7+y*6004]);
                end;
            end;
        end
        else begin
            for y:= 0 to mdeltY-1 do
            begin
                for x:=0 to 1498 do
                begin
                    bufim[2*x+0+(2*(y+mYn)+0)*3000]:=swap(FT_In_Buffer[x+7+y*1504]);
                    bufim[2*x+0+(2*(y+mYn)+1)*3000]:=swap(FT_In_Buffer[x+7+y*1504]);
                    bufim[2*x+1+(2*(y+mYn)+1)*3000]:=swap(FT_In_Buffer[x+7+y*1504]);
                    bufim[2*x+1+(2*(y+mYn)+0)*3000]:=swap(FT_In_Buffer[x+7+y*1504]);
                end;
                x:=1499;
                bufim[2*x+0+(2*(y+mYn)+0)*3000]:=swap(FT_In_Buffer[x+6+y*1504]);
                bufim[2*x+0+(2*(y+mYn)+1)*3000]:=swap(FT_In_Buffer[x+6+y*1504]);
                bufim[2*x+1+(2*(y+mYn)+1)*3000]:=swap(FT_In_Buffer[x+6+y*1504]);
                bufim[2*x+1+(2*(y+mYn)+0)*3000]:=swap(FT_In_Buffer[x+6+y*1504]);
            end;
        end;
    end;
    imageReady := true;
    cameraState:=cameraIdle;
end;

// ?????????? ????????? ?????? ???????? ??? ???????? ? ?????????? ????? val ?? ?????? adr ? ?????????? AD9822.
// ???????? ???? ? ???????????????? ????.
procedure AD9822(adr:byte;val:word);
const
    kol = 64;
var
    dan:array[0..kol-1] of byte;
    i:integer;
begin
    //??????????? ?????? ?????????????? ????????? ?? ??????? ????? BDBUS
    fillchar(dan,kol,portfirst);
    for i:=1 to 32 do
    begin
        dan[i]:=dan[i] and $fe;
    end;
    for i:=0 to 15 do
    begin
        dan[2*i+2]:=dan[2*i+2] + 2;
    end;
    if (adr and 4) = 4 then
    begin
        dan[3]:=dan[3]+4;
        dan[4]:=dan[4]+4;
    end;
    if (adr and 2) = 2 then
    begin
        dan[5]:=dan[5]+4;
        dan[6]:=dan[6]+4;
    end;
    if (adr and 1) = 1 then
    begin
        dan[7]:=dan[7]+4;
        dan[8]:=dan[8]+4;
    end;

    if (val and 256) = 256 then
    begin
        dan[15]:=dan[15]+4;
        dan[16]:=dan[16]+4;
    end;
    if (val and 128) = 128 then
    begin
        dan[17]:=dan[17]+4;
        dan[18]:=dan[18]+4;
    end;
    if (val and 64) = 64 then
    begin
        dan[19]:=dan[19]+4;
        dan[20]:=dan[20]+4;
    end;
    if (val and 32) = 32 then
    begin
        dan[21]:=dan[21]+4;
        dan[22]:=dan[22]+4;
    end;
    if (val and 16) = 16 then
    begin
        dan[23]:=dan[23]+4;
        dan[24]:=dan[24]+4;
    end;
    if (val and 8) = 8 then
    begin
        dan[25]:=dan[25]+4;
        dan[26]:=dan[26]+4;
    end;
    if (val and 4) = 4 then
    begin
        dan[27]:=dan[27]+4;
        dan[28]:=dan[28]+4;
    end;
    if (val and 2) = 2 then
    begin
        dan[29]:=dan[29]+4;
        dan[30]:=dan[30]+4;
    end;
    if (val and 1) = 1 then
    begin
        dan[31]:=dan[31]+4;
        dan[32]:=dan[32]+4;
    end;
    if (not errorWriteFlag) then
    begin
        errorWriteFlag := Write_USB_Device_Buffer_wErr(FT_HANDLEB,@dan, kol);
    end;
end;

// ???????????? 2 ??????:
// 1.??????? ??? ???????.
// 2.?/? ? ???????? 2*2.
// ???????????? ??????? ICX453 ???????? ??, ??? ?????????????? ??????? ????? ????????? ??????? ?
// ??? ????? ???? ????????????? ?????? ? ?????????????? ??????? "??????" ????? ???? ?????,
// ??????? ?????????? ????? ??? ???? ???? ???????? ??????????.

// ?????????? ????????? ?????? ???????? ? ?????????? ???? ???????? ?????? ????? ? 1 ??????}
procedure readframe;
begin
    cameraState := cameraReading;
    Purge_USB_Device_IN(FT_HANDLEA);
    comread;
    Spi_comm($1b,0);
end;

// -------------------------------------------------------------------------------
// Interface part
// -------------------------------------------------------------------------------

// Set camera gain, return bool result
function cameraSetGain (val : integer) : WordBool; stdcall; export;
begin
    //???????? AD9822
    AD9822(3,val);
    Result :=true;
end;

//Set camera offset, return bool result
function cameraSetOffset (val : integer) : WordBool; stdcall; export;
var x : integer;
begin
    x:=abs(2*val);
    if val < 0 then
    begin
        x:=x+256;
    end;
    //???????? AD9822
    AD9822(6,x);                       
    Result :=true;
end;

//Connect camera, return bool result
//????? ???????????? ????????? ? ????????????? AD9822
function cameraConnect () : WordBool; stdcall; export;
var FT_flag : boolean;
begin
    FT_Enable_Error_Report:=true;
    FT_flag:=true;
    errorWriteFlag:=false;
    sensorTempCache := 0;
    targetTempCache := 0;
    coolerOnCache := false;
    coolerPowerCache := 0;
    if (FT_flag) then
    begin
        if Open_USB_Device_By_Serial_Number(FT_HANDLEA,'CAM86A') <> FT_OK then
        begin
            FT_flag := false;
        end;
    end;
    if (FT_flag) then
    begin
        if Open_USB_Device_By_Serial_Number(FT_HANDLEB,'CAM86B')  <> FT_OK then
        begin
            FT_flag := false;
        end;
    end;
    if (FT_flag) then
    begin
        // BitMode for B-channel
        if Set_USB_Device_BitMode(FT_HANDLEB,$bf, $4)  <> FT_OK then
        begin
            FT_flag := false;
        end;
    end;
    if (FT_flag) then
    begin
        //speed = spusb
        FT_Current_Baud:=spusb;
        Set_USB_Device_BaudRate(FT_HANDLEB);

        //???????????? ??????????????
        Set_USB_Device_LatencyTimer(FT_HANDLEB,1);
        Set_USB_Device_LatencyTimer(FT_HANDLEA,1);
        Set_USB_Device_TimeOuts(FT_HANDLEA,3000,100);
        Set_USB_Device_TimeOuts(FT_HANDLEB,100,100);

        Purge_USB_Device_IN(FT_HANDLEA);
        Purge_USB_Device_OUT(FT_HANDLEA);
        Purge_USB_Device_IN(FT_HANDLEB);
        Purge_USB_Device_OUT(FT_HANDLEB);

        adress:=0;

        //????? AD9822 - ????? G,4 ?????? ?????????, CDS ?????
        AD9822(0,$d8);
        AD9822(1,$a0);
    
        CameraSetGain(0);
        //???????? ??????????????? ?????. ??? ?? ????????????? ???
        CameraSetOffset(-6);

        sleep(100);
        //send init command
        Spi_comm($db,0);
        sleep(100);
        //?????? 2 ?????, ????????? ????? reset
        Purge_USB_Device_IN(FT_HANDLEA);
        mBin:=0;
    end;
    isConnected := FT_flag;
    errorReadFlag := false;
    cameraState := cameraIdle;
    imageReady := false;
    if(FT_flag = false) then
    begin
        cameraState := cameraError;
    end;
    Result := isConnected;
end;

//Disconnect camera, return bool result
function cameraDisconnect (): WordBool; stdcall; export;
var FT_OP_flag : boolean;
begin
    FT_OP_flag := true;
    //???????? ?????????
    if Close_USB_Device(FT_HANDLEA) <> FT_OK then
    begin
        FT_OP_flag := false;
    end;
    if Close_USB_Device(FT_HANDLEB) <> FT_OK then
    begin
        FT_OP_flag := false;
    end;
    isConnected := not FT_OP_flag;
    Result:= FT_OP_flag;
end;

// Check camera connection, return bool result}
function cameraIsConnected () : WordBool; stdcall; export;
begin
    Result := isConnected;
end;

procedure ExposureTimerTick(TimerID, Msg: Uint; dwUser, dw1, dw2: DWORD); stdcall;
begin
    readframe;
end;

function cameraStartExposure (Bin, StartX, StartY, NumX, NumY : integer; Duration : double; light : WordBool) : WordBool; stdcall; export;
var expoz:integer;
begin
    errorReadFlag := false;
    imageReady := false;
    mYn:=StartY div 2;
    Spi_comm($4b,mYn);
    mdeltY:=NumY div 2;
    Spi_comm($5b,mdeltY);

    if bin = 2 then
    begin
        kolbyte:=mdeltY*3008;
        //bining
        Spi_comm($8b,1);
        mBin:=1;
    end
    else begin
        kolbyte:=mdeltY*12008;
        //no bining
        Spi_comm($8b,0);
        mBin:=0;
    end;

    expoz:=round(Duration*1000);
    if expoz > 1000 then
    begin
        expoz:=1001;
    end;
    Spi_comm($6b,expoz);

    cameraState := cameraExposing;
    if Duration > 1.0 then
    begin
        //shift3
        Spi_comm($2b,0);
        sleep(40);
        //clear frame
        Spi_comm($cb,0);
        // for time of clear frame
        sleep(180);
        //off 15v
        Spi_comm($3b,0);
        eexp:=round(1000*(Duration-1.2));
        ExposureTimer := TimeSetEvent(eexp, 100, @ExposureTimerTick, 0, TIME_ONESHOT);
    end
    else begin
        eexp:=0;
        readframe;
    end;
    Result := true;
end;

function cameraStopExposure : WordBool; stdcall; export;
begin
    TimeKillEvent(ExposureTimer);
    if (cameraState = cameraExposing) then
    begin
        readframe;
    end;
    Result := true;
end;

//Get camera state, return int result
function cameraGetCameraState : integer; stdcall; export;
begin
    if (not errorWriteFlag) then
    begin
      Result := cameraState
    end
    else begin
        Result := cameraError;
    end;
end;

//Check ImageReady flag, is image ready for transfer - transfer image to driver and return bool ImageReady flag
function cameraGetImageReady : WordBool; stdcall; export;
begin
    Result := imageReady;
end;

//Get back pointer to image
function cameraGetImage : dword; stdcall; export;
begin
    cameraState:=cameraDownload;
    cameraState:=cameraIdle;
    Result := dword(@bufim);
end;

//Get camera error state, return bool result
function cameraGetError : integer; stdcall; export;
var res : integer;
begin
  res:=0;
  if (errorWriteFlag) then res :=res+2;
  if (errorReadFlag) then res :=res+1;
  Result:=res;
end;

function cameraGetTemp (): double; stdcall; export;
var temp : double;
begin
    Spi_comm($bf,0);
    temp := (siout - TemperatureOffset) / 10.0;
    if ((temp > MaxErrTemp) or (temp < MinErrTemp)) then
    begin
        temp := sensorTempCache;
    end;
    sensorTempCache := temp;
    Result := temp;
end;

function cameraSetTemp(temp : double): WordBool; stdcall; export;
var d0:word;
begin
    d0 := TemperatureOffset + round(temp*10);
    Spi_comm($ab,d0);
    Result := true;
end;

function cameraGetSetTemp (): double; stdcall; export;
var temp : double;
begin
    Spi_comm($be,0);
    temp := (siout - TemperatureOffset) / 10.0;
    if ((temp > MaxErrTemp) or (temp < MinErrTemp)) then
    begin
        temp := targetTempCache;
    end;
    targetTempCache := temp;
    Result := temp;
end;

function cameraCoolingOn (): WordBool; stdcall; export;
begin
    Spi_comm($9b,1);
    Result := true;
end;

function cameraCoolingOff (): WordBool; stdcall; export;
begin
    Spi_comm($9b,0);
    Result := true;
end;

function cameraGetCoolerOn (): WordBool; stdcall; export;
begin
    Spi_comm($bd,0);
    if (siout = TRUE_INV_PROT) then
    begin
        coolerOnCache := true;
        Result := true;
    end
    else if (siout = FALSE_INV_PROT) then
    begin
        coolerOnCache := false;
        Result := false;
    end
    else begin
        Result := coolerOnCache;
    end;
end;

function cameraGetCoolerPower (): double; stdcall; export;
var power : double;
begin
    Spi_comm($bc,0);
    if (( siout shr 8) = (HIGH_MASK_PROT shr 8)) then
    begin
        power := (siout and $00ff) / 2.55;
    end
    else begin
        power := coolerPowerCache;
    end;
    coolerPowerCache := power;
    Result := power;
end;

exports cameraConnect;
exports cameraDisconnect;
exports cameraIsConnected;
exports cameraStartExposure;
exports cameraStopExposure;
exports cameraGetCameraState;
exports cameraGetImageReady;
exports cameraGetImage;
exports cameraSetGain;
exports cameraSetOffset;
exports cameraGetError;
exports cameraGetTemp;
exports cameraSetTemp;
exports cameraGetSetTemp;
exports cameraCoolingOn;
exports cameraCoolingOff;
exports cameraGetCoolerOn;
exports cameraGetCoolerPower;

begin

end.


